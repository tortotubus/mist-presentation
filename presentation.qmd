---
title: "A Generalized Additive Model for Temperature Forecasting in the United States"
author: Conor Olive
execute:
  cache: true
format: 
  revealjs:
    theme: style.scss
df-print: kable
bibliography: bibliography.bib
---

```{r}
#| echo: false
rm(list=ls())
```


# Methods


## Observations

- Observations are obtained from @data and contain U.S. weather stations and SNOTEL stations
- Data spans the period from 1 January 2017 to 21 September 2017 

::: {#fig-animation}

{{< video ./data/avgdaily.mp4 width="800px" >}}

Inverse distance weighted interpolation of `temp_avg` from each station for each day in the data set.
:::

---

### Predictors and Outcome

Our interest is in creating a model from the available data using

- `latitude`
- `longitude`
- `elevation`
- `date`

as predictors of `temp_avg`. 

---

### Data Cleaning

```{r, include=FALSE}
# Dataframes
library(tidyverse)
library(sf)
# Interpolation
library(gstat)
# Rasters
library(raster)
# Plotting
```

```{r}
#| label: read-csv
#| echo: false
weather <- read.csv("./data/weather.csv")
```

```{r}
#| label: remove-columns
#| echo: false

# Keep only our x and y columns from the data table
weather <- weather[c("date", "longitude", "latitude", "elevation", "temp_avg")]

# Drop observations with NA values for our x and y columns
weather <- weather %>% drop_na()
```

```{r}
#| label: date-to-days
#| echo: false

# Convert "date" column from string to date objects
weather$date <- as.Date(as.character(weather$date), format="%Y%m%d")

# Create new column counting the days since Jan 1 2017
weather$day <- as.numeric(difftime(weather$date, as.Date("20170101", format="%Y%m%d"), units="days"))

# Remove date column
weather <- weather[c("day", "longitude", "latitude", "elevation", "temp_avg")]
```

* Since date is encoded as a string, we convert it to a date object and then the number of days since 1 January 2017
* We also restrict our data to the lower 48 U.S. states and the District of Columbia. To accomplish this, we must
    * Convert our `data.frame` into a geospatial `sf` data frame object
    * Load [shapefiles](https://www2.census.gov/geo/tiger/GENZ2018/shp/cb_2018_us_state_500k.zip) for the area of interest
    * Exclude observations spatially located outside of the shapefile
    * Convert the `sf` back into a `data.frame` object

```{r}
#| warning: false
#| echo: false
#| label: data-spatial-culling
# Convert our data frame to sf
weather_sf <- st_as_sf(weather, coords = c("longitude", "latitude"), crs=st_crs("EPSG:4269"))

# Load U.S. States shapefile
states_sf <- read_sf("./data/cb_2018_us_state_500k/cb_2018_us_state_500k.shp", crs=st_crs("EPSG:4269"))

# Exclude specific states and territories
states_sf <- subset(states_sf, !(STATEFP %in% c("02","15","60","66","69","72","78")))

# Remove observations outside the remaining states and territories
weather_sf <- st_intersection(weather_sf, st_union(states_sf))

# Convert back into data frame
weather <- st_drop_geometry(weather_sf)
weather$longitude <- st_coordinates(weather_sf)[,"X"]
weather$latitude <- st_coordinates(weather_sf)[,"Y"]

```

---

* The resulting data to which we may properly fit our model

```{r}
#| echo: false
#| label: data-proccessed
weather <- weather[order(weather$day),]
rownames(weather) <- NULL

head(weather,n=9)
```

---

* Before continuing, it is worth noticing the spatial distribution of the observations in @fig-spatial-distribution. Specifically, there is a much higher distribution of observations in the inter-mountain west, which has implications for our model. These will be discussed in more detail later.

```{r}
#| echo: false
#| label: fig-spatial-distribution
#| fig-cap: "Spatial distribution of the observations within the data set."

plot_sf <- weather_sf %>% group_by(geometry) %>% slice(1)

ggplot() +
  geom_sf(data=states_sf, alpha=0) +
  geom_sf(data=plot_sf, mapping=aes(color=elevation)) +
  scale_colour_gradientn(name = "Elevation (m)", colours = terrain.colors(10)) +
  labs(x = "Longitude", y = "Latitude") +
  ggtitle("Spatial Distribution of Weather Stations") +
  theme_minimal()
```

---

* We may plot the data in two dimensions at a time and see what kind of trends, if any, exist in the data. First, looking at the effect of `latitude` on `temp_avg`

```{r}
#| echo: false
#| label: fig-data-day
#| fig-cap: "Average daily temperature versus time for all days."

plot_sf <- weather_sf %>% group_by(geometry) %>% mutate(station_id=sequence(n()))

ggplot() +
  geom_line(data=plot_sf, mapping=aes(x=day,y=temp_avg,group=station_id,color=station_id)) + 
  labs(x="Days after 1 January 2017", y="Average Daily Temperature (F)") + 
  scale_colour_gradientn(name = "Station ID", colours = terrain.colors(10)) +
  ggtitle("Average Daily Temperature By Day") +
  theme_minimal()
```

---

```{r}
#| echo: false
#| label: fig-data-elevation
#| fig-cap: "Average daily temperature versus elevation for all days."

plot_sf <- weather_sf %>% group_by(geometry) %>% mutate(station_id=sequence(n()))

ggplot() +
  geom_point(data=plot_sf, mapping=aes(x=elevation,y=temp_avg,group=station_id,color=station_id)) + 
  labs(x="Elevation (meters)", y="Average Daily Temperature (F)") + 
  scale_colour_gradientn(name = "Station ID", colours = terrain.colors(10)) +
  ggtitle("Average Daily Temperature By Elevation") +
  theme_minimal()

```

---

```{r}
#| echo: false
#| label: fig-data-latitude
#| fig-cap: "Average daily temperature versus latitude for all days."

plot_sf <- weather_sf %>% group_by(geometry) %>% mutate(station_id=sequence(n()))

ggplot() +
  geom_point(data=plot_sf, mapping=aes(x=st_coordinates(plot_sf)[,"Y"],y=temp_avg,group=station_id,color=station_id)) +  
  labs(x="Latitude", y="Average Daily Temperature (F)") + 
  scale_colour_gradientn(name = "Station ID", colours = terrain.colors(10)) +
  ggtitle("Average Daily Temperature By Latitude") +
  theme_minimal()

```

---

```{r}
#| echo: false
#| label: fig-data-longitude
#| fig-cap: "Average daily temperature versus longitude for all days."

plot_sf <- weather_sf %>% group_by(geometry) %>% mutate(station_id=sequence(n()))

ggplot() +
  geom_point(data=plot_sf, mapping=aes(x=st_coordinates(plot_sf)[,"X"],y=temp_avg,group=station_id,color=station_id)) +  
  labs(x="Longitude", y="Average Daily Temperature (F)") + 
  scale_colour_gradientn(name = "Station ID", colours = terrain.colors(10)) +
  ggtitle("Average Daily Temperature By Longitude") +
  theme_minimal()

```

---

### Elevation and the Ideal Gas Law

* Based from physical understanding of the weather, the correlation both `latitude` and `elevation` have are expected 
* First, atmospheric pressure decreases in proportion to elevation. In turn, Gay-Lussac's law informs us that
$$P \propto T$$
* Therefore, we transitively expect temperature to decrease in proportion to elevation, all else being equal

---

### Solar Irradiance and Latitude

* Irradiance is the primary forcing effect in surface temperature
* Decreases in intensity with distance from the solar equator due to the angle of incidence at which solar rays shine on the Earth.

![Demontration of the relationship between angle of incidence and intensity of solar irradiance.](./figures/solar_angle.svg){fig-align="center"}
---

* Ignoring the effect of the atmosphere on solar irradiance, geometric reasoning tells us that solar itensity $I$ at a given latitude, where $I_0$ is the intensity at the equator, is
$$ I = I_0 \cos{\theta}.$$
* However, in our data, where our latitude varies from approximately 25 to 50 degrees, this function $I$ is roughly linear, as shown in @fig-theoretical-irradiance.

```{r}
#| echo: false
#| label: fig-theoretical-irradiance
#| fig-cap: "Theoretical irradiance versus latitude in the lower 48 states."

# Define the range of theta values in degrees
theta <- seq(25, 50, by = 0.1)

# Calculate cos(theta) values
cos_theta <- cos(theta * pi / 180)  # Convert theta to radians

# Plot using ggplot2
ggplot(data.frame(theta = theta, cos_theta = cos_theta), aes(x = theta, y = cos_theta)) +
  geom_line() +
  labs(x = "Latitude (degrees)", y = "Irradiance") + 
  theme_minimal()
```

---

## Procedure

* Owing to the fact that this model is a combination of both linear and highly non-linear
physical effects, we choose to fit the data set with a *Generalized Additive Model*, implemented by @gam. 
* Our particular model is

$$\text{temp_avg} = \beta_0 + \beta_1 (\text{elevation}) + \beta_2 (\text{latitude}) + \beta_3 (\text{longitude}) + \beta_4f(\text{days}).$$
since we hypothesize the partial derivatives of `temp_avg` with respect to `longitude`, `latitude` and `elevation` to be roughly constant.

```{r}
#| echo: false
#| label: test-train-split

# Randomly choose our indices to sample from for our training set
sample_frac <- 0.7
train_inds <- sample(c(TRUE, FALSE), nrow(weather), replace=TRUE, 
                     prob=c(sample_frac,1-sample_frac))

# Create training set from training set indices
train <- weather[train_inds,]
train_x <- train[, c('elevation','longitude','latitude','day')]
train_y <- train[, c('temp_avg')]

# Create testing set from negation of training set indices
test <- weather[!train_inds,]
test_x <- test[, c('elevation','longitude','latitude','day')]
test_y <- test[, c('temp_avg')]
```


# Results

* Finally, we fit our model

```{r}
#| echo: false
#| warning: false
#| label: gam-fit
library("gam")

gam_weather <- gam(temp_avg ~ elevation + longitude + latitude + s(day,df=5), data=train)
```


* The resulting coefficients $\beta_i$ in our `gam_weather` model are

```{r}
#| echo: false
#| label: gam-coefficients
data.frame(gam_weather$coefficients)
```

* Using our testing set of data, we calculate the root mean square deviation

```{r}
#| echo: true
#| label: gam-rmse
# Use the model to make prediction based on our training set 
gam_predict <- predict(gam_weather, test_x)

# Calculate RMSE on the residuals of our prediction and training set avg_temp
gam_rmse <- sqrt(mean((gam_predict - test_y)^2))
```

* We get a root mean square deviation (RMSD) of `{r} gam_rmse`

---

* Partial residual plots for each of the independent predictors are shown below in @fig-component.

```{r}
#| echo: false
#| label: fig-component
#| fig-cap: "Partial residuals and components of the model."

par(mfrow=c(2,2),mar = c(4,4,2,1))
plot(gam_weather,residuals=TRUE,col="lightblue")
```

# Conclusions

* We aimed to forecast temperature in the US from January 1, 2017, to September 21, 2017 using latitude, longitude, elevation, and date
* Fitting a Generalized Additive Model to the data yieled acceptable results with a RMSE of `{r} gam_rmse` and captured several predicted trends

---

* The resulting model is a reasonably good predictor of temperature within the time frame of the data, especially within the inter-mountain west, but poorer outside this region

```{r}
#| echo: false
#| warning: false
#| label: fig-station-residuals
#| fig-cap: "Temperature residuals by station over time."

library(plotly)

plot_sf <- weather_sf
plot_sf$residual = predict(gam_weather, weather) - plot_sf$temp_avg

p <- ggplot() +
  geom_sf(data=states_sf, alpha=1) +
  geom_sf(data=plot_sf, mapping=aes(color=residual, frame=day)) +
  scale_colour_gradientn(
    name = "Temperature Residual (F)",
    colours = c("blue", "green", "red"),
  ) + 
  labs(x = "Longitude", y = "Latitude") +
  ggtitle("Residuals by Station") +
  theme_minimal()

ggplotly(p) %>% animation_opts(100,transition=0,redraw = FALSE)
```

# References

---
nocite: |
  @gam, @sf, @tidyverse, @raster, @gstat
---
::: {#refs}
:::